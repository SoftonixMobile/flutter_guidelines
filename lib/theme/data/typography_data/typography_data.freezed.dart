// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'typography_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AppTypographyData {
  TextStyle get head1 => throw _privateConstructorUsedError;
  TextStyle get head2 => throw _privateConstructorUsedError;
  TextStyle get subhead1 => throw _privateConstructorUsedError;
  TextStyle get subhead2 => throw _privateConstructorUsedError;
  TextStyle get body1 => throw _privateConstructorUsedError;
  TextStyle get body2 => throw _privateConstructorUsedError;
  TextStyle get caption1 => throw _privateConstructorUsedError;
  TextStyle get caption2 => throw _privateConstructorUsedError;

  /// Create a copy of AppTypographyData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AppTypographyDataCopyWith<AppTypographyData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppTypographyDataCopyWith<$Res> {
  factory $AppTypographyDataCopyWith(
          AppTypographyData value, $Res Function(AppTypographyData) then) =
      _$AppTypographyDataCopyWithImpl<$Res, AppTypographyData>;
  @useResult
  $Res call(
      {TextStyle head1,
      TextStyle head2,
      TextStyle subhead1,
      TextStyle subhead2,
      TextStyle body1,
      TextStyle body2,
      TextStyle caption1,
      TextStyle caption2});
}

/// @nodoc
class _$AppTypographyDataCopyWithImpl<$Res, $Val extends AppTypographyData>
    implements $AppTypographyDataCopyWith<$Res> {
  _$AppTypographyDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AppTypographyData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? head1 = null,
    Object? head2 = null,
    Object? subhead1 = null,
    Object? subhead2 = null,
    Object? body1 = null,
    Object? body2 = null,
    Object? caption1 = null,
    Object? caption2 = null,
  }) {
    return _then(_value.copyWith(
      head1: null == head1
          ? _value.head1
          : head1 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      head2: null == head2
          ? _value.head2
          : head2 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      subhead1: null == subhead1
          ? _value.subhead1
          : subhead1 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      subhead2: null == subhead2
          ? _value.subhead2
          : subhead2 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      body1: null == body1
          ? _value.body1
          : body1 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      body2: null == body2
          ? _value.body2
          : body2 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      caption1: null == caption1
          ? _value.caption1
          : caption1 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      caption2: null == caption2
          ? _value.caption2
          : caption2 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AppTypographyDataImplCopyWith<$Res>
    implements $AppTypographyDataCopyWith<$Res> {
  factory _$$AppTypographyDataImplCopyWith(_$AppTypographyDataImpl value,
          $Res Function(_$AppTypographyDataImpl) then) =
      __$$AppTypographyDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TextStyle head1,
      TextStyle head2,
      TextStyle subhead1,
      TextStyle subhead2,
      TextStyle body1,
      TextStyle body2,
      TextStyle caption1,
      TextStyle caption2});
}

/// @nodoc
class __$$AppTypographyDataImplCopyWithImpl<$Res>
    extends _$AppTypographyDataCopyWithImpl<$Res, _$AppTypographyDataImpl>
    implements _$$AppTypographyDataImplCopyWith<$Res> {
  __$$AppTypographyDataImplCopyWithImpl(_$AppTypographyDataImpl _value,
      $Res Function(_$AppTypographyDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of AppTypographyData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? head1 = null,
    Object? head2 = null,
    Object? subhead1 = null,
    Object? subhead2 = null,
    Object? body1 = null,
    Object? body2 = null,
    Object? caption1 = null,
    Object? caption2 = null,
  }) {
    return _then(_$AppTypographyDataImpl(
      head1: null == head1
          ? _value.head1
          : head1 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      head2: null == head2
          ? _value.head2
          : head2 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      subhead1: null == subhead1
          ? _value.subhead1
          : subhead1 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      subhead2: null == subhead2
          ? _value.subhead2
          : subhead2 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      body1: null == body1
          ? _value.body1
          : body1 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      body2: null == body2
          ? _value.body2
          : body2 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      caption1: null == caption1
          ? _value.caption1
          : caption1 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
      caption2: null == caption2
          ? _value.caption2
          : caption2 // ignore: cast_nullable_to_non_nullable
              as TextStyle,
    ));
  }
}

/// @nodoc

class _$AppTypographyDataImpl implements _AppTypographyData {
  const _$AppTypographyDataImpl(
      {required this.head1,
      required this.head2,
      required this.subhead1,
      required this.subhead2,
      required this.body1,
      required this.body2,
      required this.caption1,
      required this.caption2});

  @override
  final TextStyle head1;
  @override
  final TextStyle head2;
  @override
  final TextStyle subhead1;
  @override
  final TextStyle subhead2;
  @override
  final TextStyle body1;
  @override
  final TextStyle body2;
  @override
  final TextStyle caption1;
  @override
  final TextStyle caption2;

  @override
  String toString() {
    return 'AppTypographyData(head1: $head1, head2: $head2, subhead1: $subhead1, subhead2: $subhead2, body1: $body1, body2: $body2, caption1: $caption1, caption2: $caption2)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AppTypographyDataImpl &&
            (identical(other.head1, head1) || other.head1 == head1) &&
            (identical(other.head2, head2) || other.head2 == head2) &&
            (identical(other.subhead1, subhead1) ||
                other.subhead1 == subhead1) &&
            (identical(other.subhead2, subhead2) ||
                other.subhead2 == subhead2) &&
            (identical(other.body1, body1) || other.body1 == body1) &&
            (identical(other.body2, body2) || other.body2 == body2) &&
            (identical(other.caption1, caption1) ||
                other.caption1 == caption1) &&
            (identical(other.caption2, caption2) ||
                other.caption2 == caption2));
  }

  @override
  int get hashCode => Object.hash(runtimeType, head1, head2, subhead1, subhead2,
      body1, body2, caption1, caption2);

  /// Create a copy of AppTypographyData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AppTypographyDataImplCopyWith<_$AppTypographyDataImpl> get copyWith =>
      __$$AppTypographyDataImplCopyWithImpl<_$AppTypographyDataImpl>(
          this, _$identity);
}

abstract class _AppTypographyData implements AppTypographyData {
  const factory _AppTypographyData(
      {required final TextStyle head1,
      required final TextStyle head2,
      required final TextStyle subhead1,
      required final TextStyle subhead2,
      required final TextStyle body1,
      required final TextStyle body2,
      required final TextStyle caption1,
      required final TextStyle caption2}) = _$AppTypographyDataImpl;

  @override
  TextStyle get head1;
  @override
  TextStyle get head2;
  @override
  TextStyle get subhead1;
  @override
  TextStyle get subhead2;
  @override
  TextStyle get body1;
  @override
  TextStyle get body2;
  @override
  TextStyle get caption1;
  @override
  TextStyle get caption2;

  /// Create a copy of AppTypographyData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AppTypographyDataImplCopyWith<_$AppTypographyDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
